Understanding React Hooks

1. useContext
2. useReducer
3. useCallback
4. useMemo
5. useRef
6. useLayoutEffect
7. useHistory
8. useLocation
9. useDispatch
10. useSelector

1. useContext

defs: useContext is a React Hook that lets you read and subscribe to context from your component.

ex: 
    import { createContext, useContext, useState } from 'react';

    const ThemeContext = createContext(null);

    export default function MyApp() {
        const [theme, setTheme ] = useState('dark');
    return (
        <ThemeContext.Provider value={theme}>
        <Form />
        <Button onClick={() => {
        setTheme('light');          // updating state which is been provided by the context to the children consumers
      }}>
        Switch to light theme
      </Button>
        </ThemeContext.Provider>
    )
    }

    function Form() {
    return (
        <Panel title="Welcome">
        <Button>Sign up</Button>
        <Button>Log in</Button>
        </Panel>
    );
    }

    function Panel({ title, children }) {
    const theme = useContext(ThemeContext); // here useContext hook is used to subscribe to the ThemeContext
    const className = 'panel-' + theme;
    return (
        <section className={className}>
        <h1>{title}</h1>
        {children}
        </section>
    )
    }

    function Button({ children }) {
    const theme = useContext(ThemeContext);
    const className = 'button-' + theme;
    return (
        <button className={className}>
        {children}
        </button>
    );
    }


2. useReducer: 

defs: useReducer is a React Hook that lets you add a Reducer to your component.

Call useReducer at the top level of your component to manage its state with a reducer.

const [state, dispatch] = useReducer(reducer, initialArg, init?)

useReducer takes three parameters: 

        1. reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.

        2.initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument.

        3.init(optional): The initializer function that specifies how the initial state is calculated. If it’s not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg).

useReducer returns an array with exactly two values:

    1. The current state. During the first render, it’s set to init(initialArg) or initialArg (if there’s no init).
    2. The dispatch function that lets you update the state to a different value and trigger a re-render.


ex: 
    import { useReducer } from 'react';

    function reducer(state, action) {
    if (action.type === 'incremented_age') {
        return {
        age: state.age + 1
        };
    }
    throw Error('Unknown action.');
    }

    export default function Counter() {
    const [state, dispatch] = useReducer(reducer, { age: 42 });

    return (
        <>
        <button onClick={() => {
            dispatch({ type: 'incremented_age' })
        }}>
            Increment age
        </button>
        <p>Hello! You are {state.age}.</p>
        </>
    );
    }

3. useCallback 

defs: useCallback is a React Hook that lets you cache a function definition between re-renders.

const cachedFn = useCallback(fn, dependencies)

    Parameters 
    1. fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On subsequent renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.

    2. dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

    Returns 
    On the initial render, useCallback returns the fn function you have passed.

    During subsequent renders, it will either return an already stored fn  function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render.

4. useMemo: 

    defs: useMemo is a React Hook that lets you cache the result of a calculation between re-renders.

    const cachedValue = useMemo(calculateValue, dependencies)

        Parameters: 

        1. calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On subsequent renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it in case it can be reused later.

        2. dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

        Returns 
        On the initial render, useMemo returns the result of calling calculateValue with no arguments.

        During subsequent renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.

5. useRef:

    defs: useRef is a React Hook that lets you reference a value that’s not needed for rendering.

    const ref = useRef(initialValue)

    Parameters :

        1.initialValue: The value you want the ref object’s current property to be initially. It can be a value of any type. This argument is ignored after the initial render.

        Returns 
        useRef returns an object with a single property:

        current: Initially, it’s set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.

6. useLayoutEffect : 

    defs: useLayoutEffect is a version of useEffect that fires before the browser repaints the screen.

    difference between useEffect and useLayoutEffect

        You'll notice that the useLayoutEffect gets executed before the useEffect hook without much concern for DOM mutation. Even though the React hook useLayoutEffect is set after the useEffect Hook, it gets triggered first! Before the DOM modifications are painted, the useLayoutEffect method is called synchronously
    
7. useHistory: 

    defs: it's a react-router-dom hook can be used to navigate the page to a specific path

    ex: 
        import { useHistory } from "react-router-dom"

        const App = () => {
            const history = useHistory();

            const handleClick  = () ={
                //do something
                history.push('/page2)
            }

            return(
                <>
                    <button onClick={()=> handleClick())}
                </>
            )
        }

8. useParams: 
    defs: The useParams hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the <Route path>. Child routes inherit all params from their parent routes.

    ex: 
    import * as React from 'react';
    import { Routes, Route, useParams } from 'react-router-dom';

    function ProfilePage() {
    // Get the userId param from the URL.
    let { userId } = useParams();
    // ...
    }

    function App() {
    return (
        <Routes>
        <Route path="users">
            <Route path=":userId" element={<ProfilePage />} />
            <Route path="me" element={...} />
        </Route>
        </Routes>
    );
    }

9. useLocation: 

    defs: This hook returns the current location object. This can be useful if you'd like to perform some side effect whenever the current location changes.    

10.useDispatch: 

    defs: This hook returns a reference to the dispatch function from the Redux store. You may use it to dispatch actions as needed.

    syntax: const dispatch = useDispatch()


11.useSelector: 

    defs:Allows you to extract data from the Redux store state, using a selector function.

    syntax: const result: any = useSelector(selector: Function, equalityFn?: Function)


